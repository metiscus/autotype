/*
        This file is part of AutoType

    AutoType is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    AutoType is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with AutoType.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "generator.h"
#include "parser.h"

#include <fstream>
#include <iostream>

using namespace parser;
using namespace generator; 

/*! \internal This is not reentrant */
std::map<std::string, p_class*> gClassMap; // this is horrible

/*! \internal Generates the text for the preamble of a generated code file */
void generatePreamble( std::ofstream& file )
{
    file<<"/* This file was generated by AutoType, Do not edit! */\n";
    file<< "#pragma once\n";
    file<< "#include <map>\n";
    file<< "#include <string>\n";
    file<< "#include <list>\n";
    file<< "#include <vector>\n";
    file<< "\n";

    file<< "typedef std::string String;\n"; 
    file<< "\n";
}

/*! \internal Generates the text for a member of a class */
void generateMember ( std::ofstream& file, parser::p_class::p_member *type )
{
    if( !type->getIsListType() && !type->getIsVectorType() )
    {
        file<<"\t"<<type->getTypeName()<<"\t\tm"<<type->getName()<<";\n";
    }
    else if ( type->getIsListType() )
    {
        file<<"\tstd::list<"<<type->getTypeName()<<">\t\tm"<<type->getName()<<";\n";
    }
    else if ( type->getIsVectorType() )
    {
        file<<"\tstd::vector<"<<type->getTypeName()<<">\t\tm"<<type->getName()<<";\n";
    }
}

/*! \internal Generates the text for a generated typedef */
void generateTypedef ( std::ofstream& file, parser::p_typedef *type )
{
    std::string fullType = type->getType().getName();

    if ( type->getType().getIsListType() )
    {
        fullType = "std::list<" + fullType + ">";
    }
    else if ( type->getType().getIsVectorType() )
    {
        fullType = "std::vector<" + fullType + ">";
    }
    file<<"typedef "<<fullType<<" "<<type->getName()<<";\n";
}

/*! \internal Generates the text for a generated class */
void generateClass ( std::ofstream& file, parser::p_class *type )
{    
    // add the new type into the map
    gClassMap[type->getName()] = type;

    file<<"class " << type->getName();
    const StringList& baseClasses = type->getBaseClasses();
    bool isDerived = !baseClasses.empty();
    if( isDerived )
    {
        file<<": ";
        for(int ii=0; ii<baseClasses.size(); ++ii)
        {
            file<<"public "<<baseClasses[ii];
            if( ii<baseClasses.size()-1 )
            {
                file<<", ";
            }
        }
        file<<"\n";
    }
    file<<"{\n";
    file<<"private:\n";
    
    // generate members (and accessors ;))
    std::vector<std::string> accessorTexts;

    const TypeList& memberList = type->getMembers();
    for( int ii=0; ii<memberList.size(); ++ii )
    {
        p_class::p_member* pMember = dynamic_cast<p_class::p_member*>(memberList[ii]);
        if ( pMember )
        {
            generateMember( file, pMember );
            
            // write accessors
            std::string getFunc, getFuncConst;
            std::string fullType = pMember->getTypeName();
            
            if ( pMember->getIsListType() )
            {
                fullType = "std::list<" + fullType + ">";
            }
            else if ( pMember->getIsVectorType() )
            {
                fullType = "std::vector<" + fullType + ">";
            }
            
            getFunc = fullType + "& Get" + pMember->getName() + "( ) { return m" + pMember->getName() + ";" + " }\n";            
            getFuncConst = "const " + fullType + "& Get" + pMember->getName() + "( ) const { return m" + pMember->getName() + ";" + " }\n";
            accessorTexts.push_back( getFunc );
            accessorTexts.push_back( getFuncConst );

            std::string setFunc;
            setFunc = "void Set" + pMember->getName() + "(const " + fullType + "& in ) { m" + pMember->getName() + " = in; }\n";
            accessorTexts.push_back( setFunc );
        }
    }

    file<<"\n";
    file<<"public:\n";
    for( int ii=0; ii<accessorTexts.size(); ++ii )
    {
        file<<"\t"<<accessorTexts[ii];
    }

    const StringList& ifList = type->getInterfaces();
    // write out interfaces
    for( int ii=0; ii<ifList.size(); ++ii  )
    {
        file<<"\t"<<ifList[ii]<<" = 0;\n";
    }

    // write out base class methods
    if( isDerived )
    {
        for( int ii=0; ii<baseClasses.size(); ++ii )
        {
            if( gClassMap.count( baseClasses[ii] ) > 0 )
            {
                const StringList& baseMemberList = gClassMap[baseClasses[ii]]->getInterfaces();
                // note: the -1 here removes the destructor from consideration
                for( int jj=0; jj<baseMemberList.size() - 1; ++jj )
                {
                    file<<"\t"<<baseMemberList[jj]<<";\n";
                }
            }
        }
    }

    file<<"};\n\n";
}

/*! \internal Generates the text for a generated enumeration */
void generateEnum ( std::ofstream& file, parser::p_enum *type )
{
    file<<"enum " + type->getName() + "{\n";
    const StringList& members = type->getMembers();
    StringList::const_iterator beg = members.begin();
    for( ; beg!=members.end(); ++beg )
    {
        file<<(*beg) + "\n";
    }
    file<<"};\n";
}

/*! \brief Generates the text for a generated file
    \param[in] list A list of types to write out to the particular file.
    \internal Makes calls to files that are hidden in generator.cpp
*/
void generator::generateFile( const std::string filename, const parser::TypeList& list )
{
    std::ofstream outFile( filename.c_str(), std::ios::trunc );

    generatePreamble( outFile );

    for( int ii=0; ii<list.size(); ++ii )
    {
        p_type *pType = list[ii];
        p_typedef *pTypeDef = dynamic_cast<p_typedef*>(pType);
        p_class *pClass     = dynamic_cast<p_class*>(pType);        
        p_enum  *pEnum      = dynamic_cast<p_enum*>(pType);
        if ( pTypeDef )
        {
            generateTypedef( outFile, pTypeDef );
        }
        else if ( pClass )
        {
            generateClass( outFile, pClass );
        }
        else if ( pEnum )
        {
            generateEnum( outFile, pEnum );
        }
        else
        {
            assert(false);
        }
    }
}