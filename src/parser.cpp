/*
        This file is part of AutoType

    AutoType is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    AutoType is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with AutoType.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "parser.h"
#include <cassert>
#include <cstdio>
#include "ast.h"
#include <rapidxml/rapidxml.hpp>
#include <rapidxml/rapidxml_utils.hpp>
#include "utility.h"


/*! \brief Contains all logic and classes for parsing syntax files */
namespace parser
{
    Options parser_options_;
    
    const Options& GetOptions()
    {
        return parser_options_;
    }
    
    void ParseXMLNode(ASTPtr ast, rapidxml::xml_node<> * node)
    {
        assert(node && node->name());
        assert(ast.get());

        static int level = 0;
        //printf("%s\n", node->name());
        StringDict dict;
        extractNodeAttributes(node, dict);
        
        ASTPtr ast_node;
        std::string node_name = node->name();
        if(node_name == "class")
        { 
            printf("class '%s'\n", dict["name"].c_str());
            ast_node = std::make_shared<AST>(AST::Type_Class, dict["name"]);
        }
        else if(node_name == "member")
        {
            printf("member '%s'\n", dict["name"].c_str());
            ast_node = std::make_shared<AST>(AST::Type_Member, dict["name"]);
        }
        else if(node_name == "struct")
        {
            printf("struct '%s'\n", dict["name"].c_str());
            ast_node = std::make_shared<AST>(AST::Type_Struct, dict["name"]);
        }
        else if(node_name == "typedef")
        {
            printf("typedef '%s'\n", dict["name"].c_str());
            ast_node = std::make_shared<AST>(AST::Type_Typedef, dict["name"]);
        }
        else if(node_name == "enum")
        {
            printf("enum '%s'\n", dict["name"].c_str());
            ast_node = std::make_shared<AST>(AST::Type_Enum, dict["name"]);
        }
        else if(node_name == "enum_value")
        {
            printf("enum_value '%s'\n", dict["name"].c_str());
            ast_node = std::make_shared<AST>(AST::Type_EnumValue, dict["name"]);
        }
        else
        {
            assert(false);
        }
        
        if(ast_node.get())
        {
            ast_node->SetAttributes(dict);
            ast->AddChild(ast_node);
        
            // Now iterate over the children of this node
            if(node->first_node())
            {
                printf("has children! %d\n", level);
                ++level;
                for(rapidxml::xml_node<> *child = node->first_node(); child; child = child->next_sibling())
                {
                    ParseXMLNode(ast_node, child);
                }
                --level;
            }
            else
            {
                printf("has no children! %d\n", level);
                printf("has parent = %s\n", ast->GetName().c_str());
            }
        }
    }
    
    ASTPtr ParseXMLFile(const char* filename)
    {
        // Create the AST root node
        ASTPtr ast;

        // Open the xml file and parse the types
        rapidxml::file<> xmlFile(filename);
        rapidxml::xml_document<> doc;
        doc.parse<0>(xmlFile.data());

        // todo: version check here
        rapidxml::xml_node<> *xml_node = doc.first_node("typecc");
        if(xml_node && xml_node->first_node()) 
        {
            ast = std::make_shared<AST>(AST::Type_None, "");
            xml_node = xml_node->first_node();
            while(xml_node)
            {
                printf("+++++%s\n", xml_node->name());
                ParseXMLNode(ast, xml_node);
                xml_node = xml_node->next_sibling();
            }
        }
        
        return ast;
    }

    void GenerateFile(ASTPtr ptr, const char* filename)
    {
        std::ofstream file (filename);
        if( file.is_open() )
        {
            file<<"/* This file was generated by AutoType, Do not edit! */\n";
            if(cType::GetOptions().Get<bool>("use_old_style_guards"))
            {
                // extract only the base name of the file
                std::string path, filename_root, extension;
                explodePath(std::string(filename), path, filename_root, extension);
                std::string guard = stringToUpper(filename_root) + cType::GetOptions().Get<std::string>("old_style_sep") + std::string("H") +
                    cType::GetOptions().Get<std::string>("old_style_sep") + cType::GetOptions().Get<std::string>("old_style_postfix");
                file<< "#ifndef " << guard << "\n";
                file<< "#define " << guard << "\n";
            }
            else
            {
                file<< "#pragma once\n";
            }
            
            file<< "#include <map>\n";
            file<< "#include <string>\n";
            file<< "#include <list>\n";
            file<< "#include <vector>\n";
            file<< "\n";
        }
    }
    
    void cParser::GenerateFile( const char* filename )
    {
        std::ofstream file (filename);
        if( file.is_open() )
        {
            file<<"/* This file was generated by AutoType, Do not edit! */\n";
            if(cType::GetOptions().Get<bool>("use_old_style_guards"))
            {
                // extract only the base name of the file
                std::string path, filename_root, extension;
                explodePath(std::string(filename), path, filename_root, extension);
                std::string guard = stringToUpper(filename_root) + cType::GetOptions().Get<std::string>("old_style_sep") + std::string("H") +
                    cType::GetOptions().Get<std::string>("old_style_sep") + cType::GetOptions().Get<std::string>("old_style_postfix");
                file<< "#ifndef " << guard << "\n";
                file<< "#define " << guard << "\n";
            }
            else
            {
                file<< "#pragma once\n";
            }
            file<< "#include <map>\n";
            file<< "#include <string>\n";
            file<< "#include <list>\n";
            file<< "#include <vector>\n";
            file<< "\n";

            file<< "typedef std::string String;\n";
            file<< "\n";

            for(auto itr=mTypes.begin(); itr!=mTypes.end(); ++itr)
            {
                file<<(*itr)->GenerateCode()<<"\n";
            }

            if(cType::GetOptions().Get<bool>("use_old_style_guards"))
            {
                file<< "#endif\n";
            }
        }
    }
}
